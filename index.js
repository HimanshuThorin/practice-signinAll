const express = require("express");
const mongoose = require("mongoose");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcrypt");
mongoose.set('strictQuery', false);
const app = express();
app.use(express.json());


mongoose.connect("mongodb://0.0.0.0:27017/jwtLearn").then(() => {
    console.log("connected to database");
});

app.get("/", (req, res) => {
    res.json({
        text: "hello learn this"
    })
})


const userSchema = new mongoose.Schema({
    email: { type: String, default: "" },
    password: { type: String, select: false, default: "" }
});

const postSchema = new mongoose.Schema({
    userId: { type: mongoose.Schema.Types.ObjectId, ref: "user" },
    title: { type: String, default: "" },
    paragraph: { type: String, default: "" }
})

const User = mongoose.model("user", userSchema);
const Post = mongoose.model("post", postSchema);

app.post("/register", async (req, res) => {
    try {
        const { email, password } = req.body;
        let user = await User.findOne({ email: email })
        console.log(user, "user")
        if (user) {
            res.json({
                text: "User already exists"
            })
        }
        else {
            let hashedPassword = await bcrypt.hash(password, 10);   //will provide a hashed password
            console.log(hashedPassword, "hashed")

            let result = await User.create({
                email: email,
                password: hashedPassword
            });
            res.json({
                result: result
            })
        }
    } catch (error) {
        res.json({
            error: error
        })
    }
});

app.post("/login", async (req, res) => {
    const { email, password } = req.body;
    let user = await User.findOne({ email: email }).select("+password")
    if (!user) {
        res.json({
            text: "Register First"
        })
    } else {
        const hashingPass = await bcrypt.compare(password, user.password,);  //will give true or false
        console.log(hashingPass, "hashingPass")
        if (!hashingPass) {
            res.json({
                text: "password didnt match"
            })
        } else {
            const token = jwt.sign({ user_Id: user._id, email: user.email }, "thisismysecretkey");    //a token being generated by server while logging in.
            console.log(token, "login token")
            res.json({
                token: token
            })
        }

    }
});



app.post("/post", auth, async (req, res) => {

    jwt.verify(req.token, "thisismysecretkey", async function (err, data) {
        if (err) {
            res.sendStatus(403);
        } else {
            let post = await Post.create({
                userId: mongoose.Types.ObjectId(data.user_Id),
                title: req.body.title,
                paragraph: req.body.paragraph
            })
            res.json({
                post: post
            })
        }
    });
});


app.get("/post", auth, async (req, res) => {
    try {
        jwt.verify(req.token, "thisismysecretkey", async function (err, data) {
            if (err) {
                res.sendStatus(403);
            } else {
                let result = await Post.find({
                    userId: mongoose.Types.ObjectId(data.user_Id),
                }).populate("userId")
                console.log(result, "result")
                res.json(
                    {
                        result: result
                    }
                )
            }
        });
    } catch (error) {
        res.json({
            error: error
        })
    }

});

app.post("/postUpdate", auth, async (req, res) => {
    jwt.verify(req.token, "thisismysecretkey", async function (err, data) {
        if (err) {
            res.sendStatus(403);
        } else {
            let post = await Post.findOneAndUpdate(
                {
                    userId: mongoose.Types.ObjectId(data.user_Id),
                    _id: req.body.postId
                },
                req.body.updateQuery,

            )
            console.log(post, "updated Post")
            res.json({
                post: post
            })
        }
    })
});

app.post("/deletePost", auth, async (req, res) => {
    try {
        jwt.verify(req.token, "thisismysecretkey", async function (err, data) {
            if (err) {
                res.sendStatus(403);
            } else {
                let post = await Post.findOneAndDelete({
                    userId: mongoose.Types.ObjectId(data.user_Id),
                    _id: req.body.postId
                })
                console.log(post, "deleted post")
                res.json({
                    post: post
                })
            }
        })

    } catch (error) {
        res.json({
            error: error
        })
    }
})


//whenever we will access protected route the auth middleware will work. we have to senD Authorization with that get request.
//in every get request the auth middleware will work.
//which will ADD that TOKEN to our REQUEST.
//that token will be verified above.
app.get("/get", async(req,res)=>{
  try {
    let result =  User.find({})
    res.json({
     result: result
    })
  } catch (error) {
    res.json({
        result: error
    })
  }
})

function auth(req, res, next) {
    const bearerHeader = req.headers["authorization"];
    if (typeof bearerHeader !== "undefined") {
        const bearer = bearerHeader.split(" ");
        const bearerToken = bearer[1];
        console.log(bearerToken)
        req.token = bearerToken;
        next();
    } else {
        res.sendStatus(403);
    }
}


let port = 4000;

app.listen(port, () => {
    console.log(`listening to port ${port}`)
})




